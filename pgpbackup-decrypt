#!/bin/bash

#TODO: Documentation

progname="PGP-Backup"
libname="Decryption"
version="__VERSION__"

# ARG_POSITIONAL_DOUBLEDASH()
# ARG_POSITIONAL_SINGLE([input], [Folder to decrypt], ["."])
# ARG_OPTIONAL_SINGLE([output], [o], [Folder to store decrypted files], ["../decrypted"])
# ARG_OPTIONAL_BOOLEAN([unpack],[u],[Unpacks all archives from pgpbackup-encrypt])
# ARG_OPTIONAL_BOOLEAN([verbose],[V],[Prints more information about what the script is doing])
# ARG_OPTIONAL_BOOLEAN([quiet],[q],[Supresses all output, overwrites verbose parameter])
# ARG_HELP([short program description (optional)],[long program description (optional)])
# ARG_VERSION([echo $version])
# ARGBASH_GO()

# [ <-- needed because of Argbash

readonly inFolder="$_arg_input"
readonly outFolder="$_arg_output"

# Determine which tmp folder to use
readonly rootFolder=$(dirname $outFolder)
if [ -d "$rootFolder/tmp" ]; then
    for i in {1..9}
    do
        if [ ! -d "$rootFolder/tmp$i" ]; then
            tmp="tmp$i"
            break
        fi
    done
else
    tmp="tmp"
fi
readonly tmpFolder="$rootFolder/$tmp"

# Functions
function printHelper {
    local message=$1
    local verbose=$2

    if [ "$_arg_quiet" == "off" ]; then
        if [ $verbose == "off" ] || [ "$_arg_verbose" == "on" ]; then
            echo "$message"
        fi
    fi
}

function printLog {
    local message=$1

    printHelper "$message" "off"
}

function printVerbose {
    local message=$1

    printHelper "$message" "on"
}

function execute {
    local command=$1

    printVerbose "> $command"
    eval "$command"
}

function decrypt {
    local path=$1

    find "$path" -maxdepth 1 -type f -iname "*.gpg" | while read j
    do
        command="gpg -q --status-fd 1 --use-embedded-filename --output \"$tmpFolder/tmpfile\" \"$j\""
        origFileName=$(eval "$command" | grep -E '^\[GNUPG:\] PLAINTEXT 62 [[:digit:]]+ .*$' | cut -f 5 -d " ")
        origFileName=$(echo  "$origFileName" | awk -niord '{printf RT?$0chr("0x"substr(RT,2)):$0}' RS=%..)
        origFile="$(dirname "$j")"
        origFile="$outFolder/${origFile#$inFolder}/$origFileName"
        mv "$tmpFolder/tmpfile" "$origFile"
        if [ "$_arg_unpack" = "on" ] && [[ $origFile = *.pb.zip ]]; then
            folderName=${origFile::-7}
            if [[ "$origFile" = *backup.pb.zip ]]; then
                folderName="."
            fi
            command="unzip -q \"$origFile\" -d \"$folderName\""
            execute "$command"
            rm "$origFile"
        elif [ "$_arg_unpack" = "off" ] && [[ $origFile = *.pb.zip ]]; then
            folderName=${origFile::-7}
            mv "$origFile" "$folderName.zip"
        fi
    done

    find "$path" -mindepth 1 -maxdepth 1 -type d | while read j
    do
        decrypt "$j"
    done
}

# Start of program
printLog "$progname $version - $libname"

# Check if decrypted folder exists
if [ -d "$outFolder" ]; then
    printLog "The decrypt folder is already existing."
    printLog "Aborted."
    exit 1
fi

# Create out structure
mkdir -p "$outFolder"
mkdir "$tmpFolder"

find "$inFolder" -depth ! -path . -type d | while read i
do
    mkdir -p "$outFolder/"${i#"$inFolder"}
done

decrypt "$inFolder"

# Restore folder names
find "$outFolder" -mindepth 1 -depth -type d | while read j
do
    path=$(dirname "$j")
    hashedName=$(basename "$j")
    pattern="^${hashedName};.*$"
    if [ -f "$path/foldernames.txt" ]; then
        name=$(grep -E "$pattern" "$path/foldernames.txt" | cut -f 2 -d ";")
        if [ "$name" != "" ]; then
            mv "$j" "$path/$name"
        fi
    fi
done

find "$outFolder" -type f -iname "foldernames.txt" | while read j
do
    rm "$j"
done

# Copy decrypt stuff to decrypted folder
cp "$inFolder/decrypt.sh" "$outFolder/decrypt.sh" 2> /dev/null
cp "$inFolder/pgpbackup-decrypt" "$outFolder/pgpbackup-decrypt" 2> /dev/null

# Tidy up
rm -r "$tmpFolder"

printLog "Finished decrypting!"
exit 0
# ] <-- needed because of Argbash
